---
output: rmarkdown::github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="##", fig.retina=2, fig.path = "README_figs/README-")
```

[![Project Status: Active - The project has reached a stable, usable state and is being actively developed.](http://www.repostatus.org/badges/0.1.0/active.svg)](http://www.repostatus.org/#active) 
[![Travis-CI Build Status](https://travis-ci.org/hrbrmstr/ggalt.svg?branch=master)](https://travis-ci.org/hrbrmstr/ggalt) 
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/hrbrmstr/ggalt?branch=master&svg=true)](https://ci.appveyor.com/project/hrbrmstr/ggalt) 
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/ggalt)](https://CRAN.R-project.org/package=ggalt) 
![downloads](http://cranlogs.r-pkg.org/badges/grand-total/ggalt)

`fdaSP` : sparse functional data analysis

A comprehensive guide to using the 'fdaSP' package, covering techniques such as linear models with lasso, group lasso, sparse group lasso, and overlapping group lasso penalties.

The following functions are implemented:

- `lmSP`     : Sparse Adaptive Overlap Group Least Absolute Shrinkage and Selection Operator
- `lmSP_cv`  : Cross-validation for Sparse Adaptive Overlap Group Least Absolute Shrinkage and Selection Operator
- `f2sSP`    : Overlap Group Least Absolute Shrinkage and Selection Operator for scalar-on-function regression model
- `f2sSP_cv` : Cross-validation for Overlap Group Least Absolute Shrinkage and Selection Operator on scalar-on-function regression model
- `f2fSP`    : Overlap Group Least Absolute Shrinkage and Selection Operator for function-on-function regression model
- `f2fSP_cv` : Cross-validation for Overlap Group Least Absolute Shrinkage and Selection Operator on scalar-on-function regression model

### Required libraries

```{r}
library(glmnet)
library(leaps)
```


### Installation

```{r eval=FALSE}
# you'll want to see the vignettes, trust me
install.packages("ggplot2")
install.packages("fdaSP", dependencies = TRUE)
# OR: devtools::install_github("hrbrmstr/ggalt")
```

```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
options(width=120)
```

### Usage

#### Load the Inflation dataset

Load the Inflation dataset. We consider the quarterly changes in the Consumer Price Index (CPIAUCSL,CPILFESL) as a measure of inflation. Inflation is predicted using quarterly data from several macroeconomic indicators, see \cite{bernardi_etal.2016}. In this example, we consider quarterly observations for the period from 1991-Q3 to 2023-Q4. Further details on the variables used and their sources can be found in the data appendix of \cite{bernardi_etal.2016}.  

```{r}
load("inflation-Q.RData")

# create the response variable and the design matrix
y                  <- infl.data$CPIAUCSL
X                  <- infl.data[,3:74]
X.std              <- cbind(rep(1, nrow(X)), scale(X))       
y.std              <- scale(y)
colnames(X.std)[1] <- "intercept"

# correlation analysis
data           <- cbind(y.std, X.std[,2:19])
colnames(data) <- c("INFL", colnames(X.std)[2:19])
M              <- cor(data)
corrplot::corrplot(M, order = "AOE", method = "ellipse",
                   type = "upper", tl.cex = 0.5) 
```



```{r}
# run lm
formula <- CPIAUCSL ~ UNRATE_l1 + EC_l1 + PRFI_l1 + GDPC1_l1 + 
  HOUST_l1 + USPRIV_l1 + TB3MS_l1 + GS10_l1 + T10Y3MM_l1 +
  T10YFFM_l1 + M1SL_l1 + MICH_l1 + PPIACO_l1 + DJIA_l1 + 
  NAPMPMI_l1 + NAPMSDI_l1 + OILPRICE_l1 + GASPRICE_l1
ret.lm1 <- lm(formula = formula,
                data = infl.data)
summary(ret.lm1)
```

```{r}
# Fit whole solution path for illustration
fit <- glmnet(x = as.matrix(X)[,1:18], y = y, standardize = TRUE, nlambda = 100)
plot(fit)

# Perform tenfold cross-validation
set.seed(42)
fit.cv <- cv.glmnet(x = as.matrix(X)[,1:18], y = y, standardize = TRUE, 
                    nlambda = 100, alpha = 0.5)

# fit with best lambda
fit <- glmnet(x = as.matrix(X), y = y, standardize = TRUE, 
              lambda = fit.cv$lambda.min)
b   <- as.matrix(coef(fit))

# Visualize cross-validation error-path
plot(fit.cv)

# Get selected variables
b <- as.matrix(coef(fit.cv))
rownames(b)[b != 0]
## By default, the selected variables are based on the largest value of
## lambda such that the cv-error is within 1 standard error of the minimum
```

```{r}
# best subset
lm.subset <- regsubsets(x = X.std[,2:19], y = y.std, 
                        method = "exhaustive", nvmax = 8)
summary(lm.subset)
bic <- summary(lm.subset)$bic
rss <- summary(lm.subset)$rss
cp  <- summary(lm.subset)$cp

# define the optimal model using BIC and run LM
idx <- which(summary(lm.subset)$which[which.min(bic),] == TRUE)
coef(lm(y.std ~ X.std[,idx]-1))

# plot
plot(1:8, bic, col = "red", ylim = c(-17, 15), type = "l", lwd = 1.2)
lines(1:8, cp, col = "blue",  lwd = 1.2)
```


















